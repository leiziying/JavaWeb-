一、进程和线程
       1.进程是系统进行资源分配的最小单位 ，线程是程序执行的小单位
       2.一个进程可以有一个或者多个线程
       3.线程的启动比进程轻量级，有时也把线程叫轻量级进程
二、线程安全问题是如何引发的：
      1.基本条件是出现了数据共享了
      2.一般也是因为共享数据出现写的情况了，如果共享数据只是读取也不会出现线程安全问题
      3.三点（原子性，内存可见性，代码重排序）
三、Java中有哪些机制保证线程安全：
      1.synchronized——监视器锁 ——monitor lock
          语法：
             1）.作为方法的一个修饰符
             2）.作为代码块出现
              用synchronized修饰的普通方法，调用时分为两步：
                     找到引用指向的对象
                     尝试将该对象的锁锁上（每一个java对象都有一个锁）
             锁的地方：
                   修饰普通方法：锁在调用该方法的引用指向的对象中（this）
                   修饰静态方法：锁的是类
             抢锁：
                   处在就绪状态的线程先抢CPU再抢锁
                   即便不是同一个方法，但只要是指向同一个对象，争抢的就是同一把锁
            synchronized保证原子性：
                      通过加锁
           synchronized可以保证一定限度的可见性：
                       发生在加锁和释放锁的时机上，通过控制工作缓存的刷新来实现的，但临界区（加锁—>释放锁之间的代码）
                       的执行中间，不做任何保证。
                       理论上所有的问题都可以用synchronized解决，但是成本非常大（线程的调度成本就非常大）
      2.volatile关键字
                      语法：修饰变量 （变量修饰符）
                      1.可以保证该变量的可见性问题
                      2.可以部分保证代码的重排序问题
      3.基本通信  wait/notify....
                     1.wait会使线程状态发生变化：  RUNNABLE——>WAITING           
                     2.等的是对象的等待集上
                        wait是属于Object的一个方法，所以等在该对象的等待集上
                     3.使用的时候必须加锁，等在哪个对象上，就对哪个对象加锁
                       wait执行成功时会释放锁，被唤醒时会重新请求锁：
                            先释放object里拥有的那把锁
                            把线程放到object对象的额等待集上
                            把线程状态变成WAITING（没有资源竞争CPU）    
                            被唤醒后：
                                把自己 从等待集中取出
                                把线程 的状态变为RUNNABLE
                                尝试重新抢object的对象
                     4.哪个线程调用wait哪个线程进入等待集
                             等待集：是每个对象 的共享资源，将线程放到等待集之前要加锁保证线程安全
                     5.notify只唤醒一个，但不保证是哪一个
                     6.notifyAll  唤醒全部等待集上的线程